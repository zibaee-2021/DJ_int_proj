# WARNING THIS SCRIPT IS ORIGINALLY GENERATED BY CHATGPT4o

# PATHS ARE EXPECTING THIS TO BE CALLED FROM DJ_Intern_Code/notebooks

import os
from time import time
from tqdm import tqdm
import subprocess
import itertools
import pandas as pd
import numpy as np
from multiprocessing import Pool, cpu_count
from functools import partial
import mmseqs2
import platform

op_sys = platform.system()  # 'Linux', 'Darwin' (Darwin = macOS), or 'Windows'
TMALIGN_BIN = os.path.join('utils', op_sys, 'TMalign')

def compute_tm(pdb1, pdb2):
    try:
        result = subprocess.run(
            [TMALIGN_BIN, pdb1, pdb2],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=60
        )
        output = result.stdout
        for line in output.splitlines():
            if line.startswith('TM-score='):
                tm = float(line.split('=')[1].split()[0])
                return tm
    except Exception as e:
        print(f'Error computing TM-score for {pdb1} vs {pdb2}: {e}')
        return np.nan


def compute_tm_from_mp_pool(pair, pdb_files):
    i, j = pair
    f1 = pdb_files[i]
    f2 = pdb_files[j]
    try:
        result = subprocess.run(
            [TMALIGN_BIN, f1, f2],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=60
        )
        output = result.stdout
        for line in output.splitlines():
            if line.startswith('TM-score='):
                tm = float(line.split('=')[1].split()[0])
                return i, j, tm
    except Exception as e:
        print(f'Error computing TM-score for {f1} vs {f2}: {e}')
        return i, j, np.nan


if __name__ == '__main__':

    start = time()

    mmseqs2_results_dir =mmseqs2.rp_mmseqs_results_dir(het_hom='hethom_combined')
    homologues = pd.read_csv(os.path.join(mmseqs2_results_dir, 'homologues_30_20_90.csv'))
    non_homologues = pd.read_csv(os.path.join(mmseqs2_results_dir, 'non_homologues_30_20_90.csv'))
    prefix = os.path.join('..', 'data', 'NMR', 'raw_pdbs', 'hethom_combined')
    suffix = '.pdb'

    df["pdb1_path"] = prefix + df["pdb1"] + suffix
    df["pdb2_path"] = prefix + df["pdb2"] + suffix
    pass

    # pdbid_chain = '1cvr_A'
    # PDB_DIR = os.path.join('', 'data', 'ATLAS_parsed', pdbid_chain, 'CA_only')
    # # PDB_DIR = os.path.join('..', 'data', 'ATLAS_parsed', pdbid_chain, 'test')
    #
    # pdb_files_ = sorted([
    #     os.path.join(PDB_DIR, f)
    #     for f in os.listdir(PDB_DIR)
    #     if f.endswith('.pdb')
    # ])
    #
    # pdb_files_100_spread = [pdb_f for idx, pdb_f in enumerate(pdb_files_) if idx % 100 == 0]
    # assert(len(pdb_files_100_spread) == 101)
    #
    # # N = len(pdb_files_)
    # N = len(pdb_files_100_spread)
    # print(f'Found {N} PDB files.')
    #
    # # Generate all unique pairs (i < j)
    # pairs = list(itertools.combinations(range(N), 2))
    # print(f'Total pairs to compute: {len(pairs)}')
    #
    # # Number of worker processes
    # n_workers = max(cpu_count() - 1, 1)
    # print(f'Using {n_workers} parallel workers.')
    #
    # # Bind the extra argument
    # # _compute_tm = partial(compute_tm, pdb_files=pdb_files_)
    # _compute_tm = partial(compute_tm_from_mp_pool, pdb_files=pdb_files_100_spread)
    #
    # # List to store only interesting results
    # interesting_results = []
    #
    # with Pool(processes=n_workers) as pool:
    #     for result_ in tqdm(
    #         pool.imap_unordered(_compute_tm, pairs, chunksize=10),
    #         total=len(pairs),
    #         desc="Processing TM-scores"
    #     ):
    #         i_, j_, tm_ = result_
    #         if np.isnan(tm_):
    #             continue
    #         if tm_ <= 0.8:
    #             interesting_results.append((i_, j_, tm_))
    #
    # # Save interesting pairs as .npy
    # rpath_tm_pairs = os.path.join('', 'data', 'ATLAS_parsed', pdbid_chain, 'low_tm_pairs.npy')
    # np.save(rpath_tm_pairs, np.array(interesting_results, dtype=object))
    # print(f"Saved {len(interesting_results)} pairs with TM-score < 0.8 to {rpath_tm_pairs}.")
    print(f'Completed in {round((time() - start) / 60)} minutes.')
